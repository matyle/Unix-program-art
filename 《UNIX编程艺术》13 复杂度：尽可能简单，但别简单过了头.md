事情要尽可能简单，但别简单过了头。
KISS原则


## 13.1 谈谈复杂度

### 13.1.1 复杂度的三个来源
Unix程序员已学到了一种世界观：简单即美即雅即善，而复杂即丑即怪即恶。

Unix程序员追求简单的激情，源自注重实效的事实：复杂度就是成本。
- 复杂的软件更难于开发，难于测试，难于调试，难于维护
- 最重要的，难以学习和使用。
- 打印的代价：(年轻读者可能不会知道那些终端是打印的。在纸上打印。非常慢。)

#### 什么是复杂度
- Unix程序员注重于实现的复杂度——能够试图理解一个程序，从而建立其思维模型并调试该程序的困难程度。
- 另一方面，顾客和用户往往从程序界面的复杂度来看待这个问题。易用性及其对立面——记忆负担
- 系统中的代码行总数，即代码量。
更多行的代码意味着更多的 bug，而调试常常是开发中最昂贵、最耗时的部分。
![图片](https://cdn.jsdelivr.net/gh/matyle/tupic/img/20220824073851.png)

偶然复杂度常常缘于:
- 接口设计并非正交——即没有仔细地分解接口操作以使得每个操作只完成一件事情。
- 偶然代码复杂度（比能够完成工作所需的更复杂）常常来自于过早的优化。
- 臃肿的偶然代码库往往缘于对SPOT 原则的违背、重复的代码或糟糕的组织，以至于重用机会渺茫。

本质接口复杂度通常无法去除，除非调整软件的基本功能需求（在本章的实例分析中我们会更多地展开这个主题）。

代码库规模大小的可能增涨（假设用户可视的功能和采用的算法固定不变）通常来自于使其更具可维护性的不同实践——增加更多注解，使用更长变量名称等等。工程所涉及的任何方面均可产生可能实现复杂度。

#### 应对
复杂度的不同来源必须以不同方法应对。
代码库规模可以采用更好的工具来解决。
实现复杂度可以选择更好的算法来处理。
接口复杂度必须着眼于更好的交互设计，一种考虑了人类工程学和用户心理学在内的技能。这种技能，比编码能力更为少见（并可能更加困难）。

另一方面，处理各种复杂度，必然更仰赖于见识而非方法。通过发现更简单的方法，可以去除偶然复杂度。依赖上下文环境判断哪些功能值得去做，可以去除选择复杂度。而要去除本质复杂度，就只能通过对现实真谛的洞察和顿悟，从根本上重新定义所要解决的问题。

## 13.3 编辑器的适当规模
## 13.4 软件的适度规模
小巧锐利工具的Unix教义隐藏着二重性；许多Unix从业者都没有注意到，一个十分不明显的背景，就像鱼没有注意到它游着的水一样。这就是框架的存在。



最简原则暗示：选择需要管理的上下文环境，并且按照边界所允许的最小化方式构建程序

矫正这种趋势的方法直接来自于旧学派Unix的赞美诗集。这就是吝啬原则：只有实证了其它方法行不通时才写庞大程序——也就是，已经尝试过分解问题但遭到失败

当编制一个框架时，牢记分离原则。框架是机制（通用），尽可能少地包含策略。
逻辑和业务反转（不要让逻辑依赖逻辑）！！编制或重用框架有益于将“不这样做会是大块策略”的东西分离到独立的模块、模式或工具——可以有效地同其它程序重新组合起来的部分中去。


具体情况具体分析，而锻炼良好的判断力和品味恰好是软件设计者所追求的。正如曹洞禅所说，行程才是目的；顿悟在每日的实践中。