#linux #pionex 
[[《UNIX 编程艺术》4 第4章 模块性：保持清晰，保持简洁]]
[[《UNIX编程艺术》1 第一章 规范]]
众所周知，人类几千年前就已经发明了算盘之类的计算设备。
但很少有人知道，人类第一次使用通用计算机协议是在《旧约》中——当时摩西用控制海中止了埃及人的进程。
# 文本化：好协议产生好实践
两种不同的设计但是联系紧密：(不是特别理解)
- 设计将应用数据存储在磁盘中的文件格式，
- 在协作程序中（可能会通过网络）传递数据和命令的应用协议。

共同之处：两者都与内存数据结构的序列化有关。
>>**一个复杂数据结构最简便的表达就是所有字段都用机器自带的数据格式（如整数的二进制补码）来表示，而所有指针都是实际的存储地址（相对于名称引用而言）**
但是这些表示法并不适合数据的存储和传输；数据结构的存储地址一旦离开存储器就毫无意义
发送未经处理的原生数据格式又会因为不同机器采用不同约定（如高位字节序对低位字节序，或32位对64位）而产生传输数据的互用问题（interoperability）。

因此需要序列化：为了便于数据的传输和存储，像链表这样的数据结构，其可遍历的准空间部署需要平整化或序列化成字节流表达，以便日后能从这个表达中恢复数据结构


#### 什么是序列化（变为字节流）和反序列化（变为结构）
序列化（保存）操作有时也称为列集（marshaling），其反向操作（载入）称为散集（unmarshaling）
高级语言会内置列集和散集函数，但是依然无法解决根本问题
>>原因既包括我们上面提到的机器间的互用问题，也包括对其它工具不透明这一负面特征。\
>>例如：
>>如果应用程序是网络协议，出于经济性考虑，可能会要求内部数据结构（比如携带源地址和目标地址的信息）不是序列化成单个的大型数据包（blob），而是序列化成接收设备可拒绝的一系列尝试性处理事务或信息（这样一来，如果目的地址无效，则较大的整块信息就会被拒收）。

既然二进制协议很难扩展和干净地抽取子集，可扩展性当然也青睐文本化协议

互用性、透明性、可扩展性和存储/事务处理的经济性——这些都是设计文件格式和应用协议时需要考虑的重要方面。
>>既然二进制协议很难扩展和干净地抽取子集，可扩展性当然也青睐文本化协议。事务处理的经济性有时则会提出相反的要求——但我们应看到，首先考虑这个标准就是一种过早优化，不这么做往往是明智选择。

#### 数据格式和程序运行控制文件的区别


最根本的区别是：
- 程序通常不修改自己的运行控制文件——信息流是单向的，从启动时的文件读取流向应用程序的设置。
- 相反，数据文件格式的属性同命名资源联系在一起，应用程序既可能读也可能写。
配置文件通常都可以手工编辑，体积很小，而数据文件通常由程序生成，多大都有可能、



## 5.1 文本化的重要性
管道和套接字既可以传输文本也可以传输二进制数据。。文本流是非常有用的通用格式
- 因为人无需专门工具就可以很容易地读写和编辑文本流，这些格式是透明的（或可以设计成透明的）。
- 同时，正是文本流的限制帮助了强化封装：因为文本流不鼓励内容丰富、编码结构密集的复杂表达，也不提倡程序互相干涉内部状态

>>设计一个文本协议往往可以为系统的未来省不少力气。一个具体原因就是格式本身不能表示数字域的范围。
>>SMTP或类HTTP的文本协议存在的问题则相反。这些协议往往占据昂贵的带宽资源，解析速度很慢。最小的X请求是4个字节：最小的HTTP请求大约是100个字节
>

二进制的优点：如果要处理大批量的数据集，因而确实关注能否在介质上获得最大位密度，或是非常关心将数据转化为芯片核心结构所必须的时间或指令开销。（例如图像和多媒体）

二进制和文本的对比：
- 文本格式的位密度未必一定比二进制格式低多少；
- 设计紧凑二进制格式的思路往往不能够兼顾干净扩展的要求
- 文本具有透明性，方便扩展（比如密码文件，newsrc文件都是文本格式）



### 5.1.2 实例分析：.newsrc格式（文本）
![](https://cdn.jsdelivr.net/gh/matyle/tupic/img/20220816074538.png)
>>非Unix程序员也许会自然而然地去试图设计一个快速二进制格式，其中每个新闻组的状态采用固定的长二进制记录或由一系列内含长度字段的自描述二进制信息包来表示。这种二进制表示的要点在于：在成对字长字段内用二进制数据来表示范围，目的是避免启动时解析所有范围表达式的开销。

设计为二进制会快一些，但是这是一种过早优化，并且有很多致命缺点：
- 固定记录长度这种简单的实现会造成人为限制新闻组名称的长度，（更严重的是）限制已读文章数量范围的最大值(扩展，透明)
- 用一种更复杂的二进制包格式可避免这种长度限制，但用户无法自行查看或编辑——而当需要重新设置某个新闻组中的某个已读状态字段。（可操作性）
设计者舍经济性而取透明性和可操作性
### 5.1.3 实例分析：PNG图形文件格式（二进制）
为什么图像用二进制？因为我们不关心他的具体内容（不需要透明性），我们关心图像
>> 别搞错，PNG格式支持另一种透明性——透明像素。
[[《UNIX 编程艺术》6 透明性：来点儿光]]


PNG格式是二进制文件格式中一个经过周密设计的优秀例子。既然图形文件包含了大量的数据，
- 如果像素数据用文本格式来存储的话，尺寸和网络下载时间都会显著提高，因此二进制格式非常合适，传输经济性是要考虑的主要问题，透明性则牺牲了[3]
- 设计者对互用性非常谨慎：PNG格式指定了字节顺序、整数的字长、优先顺序，和（但缺少）字段间的填充。
PNG文件头同样值得研究。它设计得非常聪明，能使各种常见的文件损坏情况（如7位传输连接，或CR字符和LF字符的损坏）很容易被发现。


## 5.2 数据文件元格式
数据文件元格式是一套句法和词法约定，这套约定或者已经正式标准化，或者已经通过实践得到了充分的确定，已有标准服务库来处理列集和散集操作。
>>grep（1）、sed（1）、awk（1）和 cut（1）这些文本搜索和变换工具的组合。对以上工具所提倡的面向行格式的解析，Perl和其他脚本语言通常自带支持功能。


### 5.2.1 DSV 风格
DSV代表“Delimiter-Separated Values（分隔符分隔值）”。冒号作为值分隔符的DSV格式(json),这种风格的数据文件一般应通过反斜杠（\）转义符支持在数据域中包含冒号


>>事实上，Microsoft版CSV是一个如何设计文本文件格式的典型反面例子。问题首先出现在字段正好含有分隔字符（在这种情况下是逗号）的情况中。Unix的方法是简单的用反斜杠转义分隔符，用双反斜杠表示反斜杠字面值。在解析文件时，这种设计只要检查一种特殊情况（转义符），发现转义符时只要一个操作（解析跟在转义符后的字符）。后者不仅方便了分隔符的处理，而且还能自由处理转义符和新行符。CSV则相反，如果字段值中存在分隔符，就将整个字段值包括在双引号内。如果字段值包含双引号，整个字段值也得包括在双引号内，字段中的单个双引号需要重复两遍才能表明自己并不结束整个字段。

### 5.2.2 RFC 822 格式
RFC 822格式源自互联网电子邮件信息采用的文本格式；（在被RFC 2822取代前） RFC 822 一直是描述这种格式的主要互联网 RFC

### 5.2.3 Cookie-Jar格式

### 5.2.4 Record-Jar格式


### 5.2.5 XML
设计文本格式最难处理的问题是引句（quoting）、空格符和其它低级语法细节。用户文件格式常常因为语法结构上的轻微错误而不能跟类似格式匹配。使用XML之类的标准格式，可以由标准程序库来校验并解析，解决了这些问题中的绝大部分。

选择 XML 可以简化问题，也可能使问题复杂化。对它的大肆吹捧很多，但不要不加批判地采用或拒绝，否则就会成为时尚的牺牲品。请谨慎选择，牢记KISS原则。


### 5.2.7 Unix文本文件格式的约定
- 如果可能，以新行符结束的每一行只存一个记录
- 如果可能，每行不超过80个字符
-  使用“＃”引入注释。
- 支持反斜杠约定
>> 支持嵌入不可打印控制字符的最自然方法，就是解析C 语言风格的反斜杠转义——\n 表示新行，\r 表示回车，\t 表示制表符，\b 表示退格，\f表示走纸，\e表示ASCII escape（27），\nnn或\onnn或\0nnn表示八进制值为nnn的字符，\xnn表示十六进制值为nn的字符，\dnnn表示十进制值为nnn的字符，\\表示实际意义上的反斜杠。还有一个较新但也应当遵守的约定是使用\unnn表示十六进制的Unicode字面值。

- 在每行一条记录的格式中，使用冒号或任何连续的空白作为字段分隔符。冒号约定似乎起源于Unix的口令文件。如果某个字段必须包含分隔,使用反斜杠
- 不要过分区别tab和whitespace。
-  优先选用十六进制而不是八进制。
- 对于复杂的记录，使用“节（stanza）”格式：一个记录若有多行，就使用\%\%\n或\%\n作为记录分隔符。
- 在节格式中，要么每行一个记录字段，要么让记录格式和RFC 822电子邮件头类似，用冒号终止的字段名关键字作为引导字段。
-  在节格式中，支持连续行
- 要么包含一个版本号，要么将格式设计成相互独立的自描述字节块。
- 注意浮点数取整问题。
- 不要仅对文件的一部分进行压缩或二进制编码。

### 5.2.8 文件压缩的利弊


## 应用协议设计
- 如果应用协议是文本式的，而且仅凭肉眼就能很容易地分析，那么很多好事情就更容易实现了。事务转存更容易解释。测试负载也更容易编写。
- 另一个需要牢记在心的问题是端对端（end-to-end）设计守则（怎么做到端到端）
- 就是为获得良好的性能而设计应用协议
