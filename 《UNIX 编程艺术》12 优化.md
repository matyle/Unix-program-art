12 优化
过早优化乃万恶之源。

Unix的经验告诉我们最主要的就是如何知道何时不去优化

其次，最有效的优化往往是优化之外的其它事情，如：清晰干净的设计。


- 如果仅仅只是常数部分而优化，不值得。
- 更明智的做法是集中精力将时间复杂度或空间复杂度从 O（n2）降至O（n）或O（n log n）[1]，或者类似地，从一个更高次的指数降下来。线性性能增益往往很快就会被摩尔定律覆盖了。[2]
- 另一个非常有建设性的“无为”方式就是不写代码。程序性能不可能因不存在的代码而降低。而存在、但不如所设想那样高效的代码可能会降低程序的性能——但那是另一码事了。

## 12.2 先估量，后优化
如果有真凭实据证明应用程序运行缓慢，这时（仅当此时）才可以考虑优化代码。但付诸实施前，要先估量。(利用 pprof)

将这些误差源影响降到最低的一个方法，就是综合多次profiler结果，可以在一般情况下得到更好的运行时间图。有不少充足理由支持在优化之前为程序编制测试工具和测试负载；这远比性能调整重要得多，在程序改变之后，可以进行回归测试以检验其正确性。****

## 12.3 非定域性之害
- 最有效的代码优化方法就是保持代码短小简单。
- 这儿还有个新的：永远不要将核心数据结构和时间关键循环抛出缓存。

把目标机器看成一个存储类型的分层结构，按照距离处理器的远近来排列：处理器自身的寄存器；指令管线；一级缓存（L1）；二级缓存（L2）；可能还有三级缓存（L3）；主存（Unix老手仍然别致地称之为“核心”）；以及交换空间所在的磁盘驱动器。

因此在这里，“小即是美”的建议比以往更有用，尤其是考虑到核心数据结构必须留在最快的缓存里。该建议也同样适用于代码；通常，指令加载要比执行花费的时间更多。

更普遍的是，不妨悲观地认为，许多优化方法都是暂时的而且常常随着成本比例而变化。唯一可去了解的方法就是衡量后再看。

## 12.4 吞吐量和延迟



### 12.4.2 重叠操作


### 12.4.3 缓存操作结果
有时，按需计算出昂贵的结果，再缓存起来为以后使用，通过这种方法可以兼得鱼和熊掌（低延迟和高吞吐量）。
- 进制缓存的使用可以消除有关文本数据库文件解析的开销
- 所有涉及二进制缓存的代码必须检查两个文件的时间戳，如果主文本更新了，则必须相应更新缓存。主文本的所有变化都必须通过一个能够更新二进制格式的包装器来完成。
- 重复的数据表明这种存储不具备经济性——这是一个纯粹的速度优化。但真正的问题是确保缓存和主文本一致的代码非常容易产生漏洞和 bug。
“真理的单点性（Single Point of Truth）”或者SPOT原则。
[[《UNIX 编程艺术》4 第4章 模块性：保持清晰，保持简洁]]

认为迫切需要缓存的时候，明智的做法是能够从更深层次来考虑，并问问为什么缓存是必须的。这比将缓存的所有边界条件都考虑到要容易得多。