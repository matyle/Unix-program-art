#book 
[[《UNIX编程艺术》1 第一章 规范]]

<div class="rich-link-card-container"><a class="rich-link-card" href="https://weread.qq.com/web/reader/f1f32dd072021a42f1fbdef" target="_blank">
	<div class="rich-link-image-container">
		<div class="rich-link-image" style="background-image: url('https://rescdn.qqmail.com/node/wr/wrpage/style/images/independent/appleTouchIcon/apple-touch-icon-152x152.png')">
	</div>
	</div>
	<div class="rich-link-card-text">
		<h1 class="rich-link-card-title">UNIX编程艺术-埃瑞克·S·理曼德-微信读书</h1>
		<p class="rich-link-card-description">
		本书主要介绍了Unix系统领域中的设计和开发哲学、思想文化体系、原则与经验，由公认的Unix编程大师、开源运动领袖人物之一Eric S. Raymond倾力多年写作而成。包括Unix设计者在内的多位领域专家也为本书贡献了宝贵的内容。本书内容涉及社群文化、软件开发设计与实现，覆盖面广、内容深邃，完全展现了作者极其深厚的经验积累和领域智慧。
		</p>
		<p class="rich-link-href">
		https://weread.qq.com/web/reader/f1f32dd072021a42f1fbdef
		</p>
	</div>
</a></div>

软件设计有两种方式：
- 一种是设计得极为简洁，没有看得到的缺陷；
- 另一种是设计得极为复杂，有缺陷也看不出来。**第一种方式的难度要大得多**。

## 4.2 紧凑性和正交性

### 4.2.1 紧凑性和正交性
紧凑性就是一个设计是否能装进人脑中的特性。
- 如果一个设计构建在易于理解且利于组合的抽象概念上，则这个系统能在具有非常强大、灵活的功能的同时保持紧凑。
- 人类短期记忆能够容纳的不连续信息数就是七，加二或减二。这给了我们一个评测API紧凑性的很好的经验法则：编程者需要记忆的条目数大于七吗？如果大于七，则这个API不太可能算是严格紧凑的。
- C++是反紧凑性的——该语言的设计者已经承认，他根本不指望有哪个程序员能够完全理解C++。


### 4.2.2 正交性
显示器就是正交控制的。你可以独立改变亮度而不影响对比度，而色彩平衡控制（如果有的话）也独立于前两个属性

>>重构（refactoring）概念是作为“极限编程（Extreme Programming）”学派的一个明确思想首次出现的，跟正交性紧密相关
>

### ### 4.2.3 SPOT原则
不要重复自身（Don't Repeat Yourself＂）”，意思是说：任何一个知识点在系统内都应当有一个唯一、明确、权威的表述

“真理的单点性（Single Point of Truth）”或者SPOT原则。

- 重复会导致前后矛盾、产生隐微问题的代码，原因是当你修改重复点时，往往只改变了一部分而并非全部。

可以通过重构去除重复代码（应该是做好应该做的版本之后优化的事情）

- 如果代码中含有重复数据是因为在两个不同的地方必须使用两个不同的表现形式，能否写个函数、工具或代码生成程序，让其中一个由另一个生成，或两者都来自同一个来源？
- 如果文档重复了代码中的知识点，能否从部分代码中生成部分文档，或者反之，或者两者都来自同一个更高级的表现形式？
- 如果头文件和接口声明重复了实现代码中的知识点，是否可以找到一种方法，从代码中生成头文件和接口声明？
>>数据结构也存在类似的SPOT原则：“无垃圾，无混淆”（No junk，no confusion）。“无垃圾”是说数据结构（模型）应该最小化，比如，不要让数据结构太通用，居然还能表示不可能存在的情况。
>
>> 无混淆”是指在真实世界中绝对明确清晰的状态在模型中也应该同样明确清晰。
>
#### 推论
更深入Unix传统一步，我们可以从SPOT原则得出以下推论：
- 是不是因为缓存了某个计算或查找的中间结果而复制了数据？仔细考虑一下，这是不是一种过早优化；陈旧的缓存（以及保持缓存同步所必需的代码层）是滋生bug的温床，而且如果（实际经常是）缓存管理的开销比预想的要高，甚至可能降低整体性能[4]。
- 如果有大量重复的样板代码，是不是可以用单一的更高层表现形式生成这些代码、然后通过提供不同的细调选项生成不同个例呢？到此，读者应该能看出一个轮廓逐渐清晰的模式。（pattern）应该是写好代码之后考虑的！！！！！不要过早优化
## 4.3
### 4.3.2 胶合层
#### 什么是胶合层？
连接两个不同模块？软件和硬件？

Unix程序员几十年的教训之一就是：胶合层是个挺讨厌的东西，必须尽可能薄，这一点极为重要。胶合层用来将东西粘在一起，但不应该用来隐藏各层的裂痕和不平整。

薄胶合层原则可以看作是分离原则的升华。策略（应用逻辑）应该与机制（域原语集）清晰地分离。如果有许多代码既不属于策略又不属于机制，就很有可能除了增加系统的整体复杂度之外，没有任何其它用处。

### 4.3.3 实例分析：被视为薄胶合层的C语言（不要太厚）
这段历史很值得回味和了解，因为C语言向我们展示了一个清晰、简洁的最简化设计能够多么强大。如果Thompson和Ritchie当初没有这么明智，他们设计的语言也许能完成更多任务，但要依赖更强的前提，永远都无法满意地从原始的硬件平台移植出去，也必将随着外部世界的改变而消亡.
完美之道，不在无可增加，而在无可删减）。

他们仍努力使C语言成为尽可能薄的“硬件之上的胶合层”。(简洁)
以前每当我要求在C语言中加一些特别奢侈的功能时，Dennis就对我说，“如果你需要PL/1，你知道到哪里去找”


## 程序库
Unix编程风格强调模块性和定义良好的API，它所产生的影响之一就是：强烈倾向于把程序分解成由胶合层连接的库集合，特别是共享库（在Windows和其它操作系统下叫做“动态连接库”（DLL）。

可以将程序划分开来：
- 一个是用户界面处理的主要部分（策略），
- 另一个是服务例程的集合（机制），中间不带任何胶合层。



## 4.5 Unix和面向对象语言

1980年代中期起，大多数新的语言设计都已自带了对“面向对象”（OO）编程的支持。回想一下，在面向对象的编程中，作用于具体数据结构的函数和数据一起被封装在可视为单元的一个对象中。
- 非 OO 语言中的模块使数据和作用于该数据的函数的联系变得相当无规律
- 而且模块间还经常互相泄漏数据或内部细节。

对 OO 的怀疑：
- Unix程序员一直比其他程序员对OO更持怀疑态度，原因之一就源于多样性原则。
- 过分推崇为解决软件复杂性问题的唯一正确办法

Unix的模块化传统就是薄胶合层原则，也就是说，硬件和程序顶层对象之间的抽象层越少越好。
在C语言中模仿真正的对象很费力。正因为这样，堆砌抽象层是一件非常累人的事。这样，C 语言中的对象层次倾向于比较平坦和透明。即使Unix程序员使用其它语言，他们也愿意继续沿用Unix模型教给他们的薄胶合/浅分层风格。


相反，OO语言使抽象变得很容易——也许是太容易了。
OO语言鼓励“具有厚重的胶合和复杂层次”的体系。
- 当问题域真的很复杂、确实需要大量抽象时，这可能是好事
- 如果编码员到头来用复杂的办法来做简单的事情——仅仅是为他们能够这样做，结果便适得其反。(用复杂的方法做简单的事情，往往得不偿失)

#### 陷阱
当问题域真的很复杂、确实需要大量抽象时，这可能是好事
如果编码员到头来用复杂的办法来做简单的事情——仅仅是为他们能够这样做，结果便适得其反。
- 所有的 OO 语言都显示出某种使程序员陷入过度分层陷阱的倾向。
- 过多的层次破坏了透明性。
>>我们很难看清这些层次，无法在头脑中理清代码到底是怎样运行的

- 可能正是因为许多编程课程都把厚重的软件分层作为实现表达原则的方法来教授，这种趋势还在恶化
- 这种现象的一个确定标志就是抽象子类或混入（mix-in's）类的不断扩散。
- OO抽象的另一个副作用就是程序往往丧失了优化的机会

#### 怎么对待面向对象 OO 语言
- Unix程序员知道什么时候不该用OO；就算用OO，他们也尽可能保持对象设计的整洁清晰
- 如果你知道自己在做什么，三层就足够了；但如果你不知道自己在做什么，十七层也没用。

## 4.6 模块式编码
### 复盘代码应该问自己的问题

- 有多少全局变量？全局变量对模块化是毒药，很容易使各模块轻率、混乱地互相泄漏信息[8]（ 全局变量同时也意味着代码不能重入；也就是说，同一进程的多个实例可能彼此干涉。）
- 单个模块的大小是否在 Hatton 的“最佳范围”内？(200-400行)
- 模块内的单个函数是不是太大了？如果不能用一句话来简单描述一个函数与其调用程序之间的约定，这个函数可能太大了[9]。(在函数原型之后立即写一行注释。每个函数都这样，决无例外.看能不能一句话描述完函数的功能)
- 代码是不是有内部 API——即可作为单元向其他人描述的函数调用集和数据结构集，并且每一个单元都封装了某一层次的函数，不受其它代码的影响。通过电话向另一个程序员描述。如果说不清楚，API很可能就是太复杂，设计太糟糕了。
- API 的入口点是不是超过七个？有没有哪个类有七个以上的方法？数据结构的成员是不是超过七个？
-   整个项目中每个模块的入口点数量如何分布[10]？是不是不均匀？有很多入口点的模块真的需要这么多入口点吗？模块复杂性往往和入口点数量的平方成正比（ 收集这种信息有一个简便的方法，就是分析etags（1）或ctags（1）等工具程序生成的标记文件。）

>>就我个人而言，如果**局部变量太多**，我倾向于拆分子程序。
另一个办法是**看代码行是否存在（太多）缩进**。我几乎从来不看代码长度。—Ken Thompson

>> [9]很多年前，我从Kernighan和Plauger的《编程风格的元素》（The Elements of Programming Style）一书中学到一个非常有用的原则，就是在函数原型之后立即写一行注释。每个函数都这样，决无例外。

[[golang 设计模式学习]]
[[《UNIX 编程艺术》5 文本化：好协议产生好实践]]