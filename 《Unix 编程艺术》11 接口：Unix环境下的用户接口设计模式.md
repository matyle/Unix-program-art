11 接口：Unix环境下的用户接口设计模式

lnterfaces:User-lnterface Design Patterns in the Unix EnvironmentAll our knowledge has its origins in our perceptions.
	我们所有的知识都来源于我们的感知。—Leonardo Da Vinci—达·芬奇


## 11.1 最小立异原则的应用
最小立异原则：“少来标新立异”，是所有接口设计中的通用原则，且并非仅局限于软件设计。

最小立异原则不应被理解为在设计中号召机械的保守主义。新颖性提高了用户与接口最初几次的交互成本，但是糟糕的设计永远使得接口令人痛苦而多余.

我们提倡以**共生和委派策略**来提高代码的复用并降低软件复杂度。此处的要点是，如果用户能够截获委派，并且将其导向他们自己选择的一个代理时，这些技法就不仅仅给开发者带来实惠，也主动地增强了用户的自主权



## 11.2 Unix接口设计的历史


## 11.3 接口设计评估
我们将使用五种度量标准对接口风格进行分类：简洁、表现力、易用、透明和脚本化能力。

- 程序接口的简洁是指一个事务处理需要的动作时间及复杂度有较低的上限（可以用击键量、鼠标手势量和需要多少秒的注意力来衡量）
- 接口具有表现力是指接口可以触发相当广泛的行为。最具表现力的接口可以启动程序设计者没有预见的行为组合，并仍然给予用户有用和一致的结果。
- 接口易用性同接口要求用户记忆的东西成反比
- 接口透明度是用户在使用接口时，几乎没有什么问题、数据或程序的相关状态需要记忆。
- 后一点——自动完成重复的任务——比以往更值得注意

## 11.4 CLI和可视接口之间的权衡
- 一是命令行和命令语言接口比起可视接口来说，更具表达力，尤其是针对复杂的任务。
- 另一个是CLI接口具有高度的脚本化能力——正如我们在第七章讨论的一样，它们很容易就能支持程序的搭配。通常（但并不总是）CLI在简洁性上也占据优势。

劣势：
- 几乎总是需要费劲地记忆（易用性低），并且透明度通常也很低。
- 其它操作系统中“用户友好”的 GUI，也存在自身的问题

## 11.5 透明、表现力和可配置
Unix程序员默认地使得接口富有表现力和透明，并且更愿意牺牲易用性来换取这些品质。这种态度常常被描述成，接口是“程序员写给程序员的”。但这过度简化了事情的某一重要方面

这种态度（也是“机制，而非策略”的近亲）的不利方面是这种倾向：当高度可配置和富于表现力的接口完成后，任务就算完了……即使其结果就是除他自己外的所有人不经长期学习几乎就无法使用


## 11.6 Unix接口设计模式

### 11.6.1 过滤器模式
与Unix相关的最经典的接口设计模式非过滤器莫属。


1.  牢记 Postel 原则：宽进严出。也就是说，尽可能自由宽松地接受输入格式，并输出结构良好的严谨输出格式。
2. 在过滤时，不需要的信息也决不丢弃。这也提升了过滤器将来能够成为其它程序有用输入的可能。丢弃的信息，在管线后面就再也不能使用了。
3. 在过滤时，绝不增加无用数据。避免增加不必要的信息，避免以可能让管线下游程序难以解析的格式输出.
4. 

### 11.6.2 Cantrip模式
cantrip 接口设计模式是其中最简单的。没有输入，没有输出，只被调用一次，产生退出状态数值。


### 11.6.3 源模式
“源”是一种类似过滤器的程序，不需要输入；它的输出只能在启动条件中控制。可以作为例证的程序是ls（1），Unix的列举目录命令。其它经典的例子包括who（1）和ps（1）。

### 11.6.4 接收器模式
接收器是一种类似过滤器的程序，只接纳标准输入而不发送任何东西到标准输出。同样，它对输入端数据的作用行为只能在启动条件中控制。


### 11.6.7 Roguelike 模式


### 11.6.8 “引擎和接口分离”模式
在Unix世界中，这种策略的应用方式通常是：将程序的“引擎”部分（程序定义域的核心算法和逻辑规格）从“接口”部分（接受用户命令、显示结果、或者提供交互帮助和命令历史记录）分离。

## 11.7 应用Unix接口设计模式


## 11.8 网页浏览器作为通用前端


## 11.9 沉默是金
- 理由一：喋喋不休的程序往往不能跟其它的程序很好地合作。较好的方法是只把真正的错误信息发送到标准的错误输出端，而不要发送任何未请求的信息
- 理由二：用户屏幕的纵向空间是宝贵的。程序每产生一行垃圾，用户可见的信息就少了一行。
- 理由三：垃圾信息是对用户带宽的无谓消耗。在屏幕上，这又增加了一个分心的来源，往往让人们不得不在处理更重要的前台工作（例如同他人的交流）的同时耗费心力。
长时间的操作要提供进度条。